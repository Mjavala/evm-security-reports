# Bug Notes

*In the current rewards accounting, vault shares in deposit() and redeem() can not correctly record the spot yields generated by the staked asset. Yields are released over the next rewards cycle. As a result, malicious users can steal yields from innocent users by picking special timing to deposit() and redeem().*

## Github Issue

[M-02](https://github.com/code-423n4/2022-09-frax-findings/issues/110)

---

The crux of this issue is with regards to the ``xERC4626 syncRewards`` function, defined below:

```solidity
// lib/ERC4626/src/xERC4626.sol
function syncRewards() public virtual {
    // ...
    uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;
    storedTotalAssets = storedTotalAssets_ + lastRewardAmount_;
    uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;
    lastRewardAmount = nextRewards.safeCastTo192();
    // ...        
    rewardsCycleEnd = end;
}
```
<br>

The first vulnerability is defined as follows:
<br>

*If withdraw just after the rewardsCycleEnd timestamp, a user can not get the yields from last rewards cycle. Since the totalAssets() only contain storedTotalAssets but not the yields part. It takes 1 rewards cycle to linearly add to the storedTotalAssets.*
<br>

I found this [explanation](https://github.com/code-423n4/2022-09-frax-findings/issues/308) to be the most intuitive. Essentially, if ``syncRewards`` is not called before deposits, withdrawals, or redeem, the disparity between the actual yield in the contract and what is used to calculate ``totalAssets`` could grow quite large.

```solidity
    function totalAssets() public view override returns (uint256) {
        // cache global vars
        uint256 storedTotalAssets_ = storedTotalAssets;
        uint192 lastRewardAmount_ = lastRewardAmount;
        uint32 rewardsCycleEnd_ = rewardsCycleEnd;
        uint32 lastSync_ = lastSync;

        if (block.timestamp >= rewardsCycleEnd_) {
            // no rewards or rewards fully unlocked
            // entire reward amount is available
            return storedTotalAssets_ + lastRewardAmount_;
        }

        // rewards not fully unlocked
        // add unlocked rewards to stored total
        uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);
        return storedTotalAssets_ + unlockedRewards;
    }
```
<br>

You can imagine that if ``syncRewards()`` is never called, or more stringently not called on every period start, this function will always return ``storedTotalAssets_ + lastRewardAmount_;`` instead of linearly interpolating.
